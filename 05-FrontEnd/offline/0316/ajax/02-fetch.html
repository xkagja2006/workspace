<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // ajax처리를 위한 모듈화 : fetch
      // XMLHttpRequest 공통으로 쓰이는 부분을 함수 하나로 대체
      console.dir(fetch);
      // url
      // let p = fetch('member.txt'); //promise객체를 반환한다.
      // axios // promise객체를 반환한다.
      // promise객체는 ES6부터 지원되었음
      // 비동기 연산이 종료된 이후의 결과값이나 실패 이유를 처리하기 위해서 연결하는 방법을 지원
      // promise 를 이용하면 비동기 메서드에서 동기 메서드 처럼 값을 반환 할 수 있다.
      let test = fetch('member.txt').then(function (data) {
        console.log('성공~!', data);
      });

      //new Promise(executor)
      //executor : 콜백 함수를 지정한다. (resolve - 성공시 호출될 콜백 함수, reject - 실패시 호출될 콜백 함수)
      //resolve, reject 는 이름과 상관 없음.
      //resolve함수를 호출하면 then 실행 => p.then(). 성공했을때 처리할 함수를 p.then 함수에 설정하면 된다. then()의 실행결과는 또 promise를 반환한다.
      //reject함수를 호출하면 catch 실행
      const p = new Promise(function (resolve, test) {
        //성공 시 resolve 함수 실행 -> readyState === 4 && status === 200 인 경우와 같다고 생각!
        //실패 시 resolve 함수 실행
        console.log('executor 실행');
        // resolve(매개변수); => p.then(function (매개변수) {})
        resolve('매개변수');
      });

      // .then.then ... => 동기처럼 사용된다.
      p.then(function (data) {
        console.log('성공', data);
        return '두번째성공';
      })
        .then(function (data2) {
          console.log('성공2', data2);
        })
        .catch(function () {
          console.log('실패');
        });
      console.log(1111); // executor 실행 보다 1111이 먼저 실행된다.비동기니깐
      console.log(p);
    </script>
  </body>
</html>
